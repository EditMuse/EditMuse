// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

// Note that some adapters may set a maximum length for the String type by default, please ensure your strings are long
// enough when changing adapters.
// See https://www.prisma.io/docs/orm/reference/prisma-schema-reference#string for more information
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Session {
  id                  String    @id
  shop                String
  state               String
  isOnline            Boolean   @default(false)
  scope               String?
  expires             DateTime?
  accessToken         String
  userId              BigInt?
  firstName           String?
  lastName            String?
  email               String?
  accountOwner        Boolean   @default(false)
  locale              String?
  collaborator        Boolean?  @default(false)
  emailVerified       Boolean?  @default(false)
  refreshToken        String?
  refreshTokenExpires DateTime?
}

enum PlanTier {
  TRIAL
  LITE
  GROWTH
  SCALE
  PRO
}

model Shop {
  id                String             @id @default(cuid())
  domain            String             @unique
  accessToken       String
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  experiences       Experience[]
  conciergeSessions ConciergeSession[]
  subscription      Subscription?
  trialStartedAt    DateTime?
  trialEndsAt       DateTime?
  usageEvents       UsageEvent[]
  aiRankingCaches   AIRankingCache[]
  orderAttributions OrderAttribution[]
  attributionAttempts AttributionAttempt[]
  experiments       Experiment[]
  appErrors         AppError[]
  appProxyLogs      AppProxyLog[]
  
  // Widget settings
  buttonLabel       String?
  placementMode     String? // "inline" | "sticky" | "both"
  defaultResultsCount Int? // 8 | 12 | 16
  widgetMode        String? // "quick" | "guided"
  widgetTheme       String? // "light" | "dark"
  installedBlockIdentifiers String? // JSON array of block identifiers (e.g., ["editmuse_concierge", "editmuse_results"])
  storefrontTestUrl String? // URL to test for extension installation (e.g., https://shop.myshopify.com/)
}

model Experience {
  id                  String             @id @default(cuid())
  shopId              String
  shop                Shop               @relation(fields: [shopId], references: [id], onDelete: Cascade)
  name                String
  mode                String // "quiz" | "chat" | "hybrid"
  resultCount         Int                @default(8) // 8 | 12 | 16
  tone                String?
  includedCollections String             @default("[]") // JSON array of collection IDs
  excludedTags        String             @default("[]") // JSON array of tag strings
  inStockOnly         Boolean            @default(false)
  isDefault           Boolean            @default(false)
  questionsJson       String             @default("[]") // JSON array of question objects
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  conciergeSessions   ConciergeSession[]

  @@index([shopId])
  @@index([shopId, isDefault])
}

enum ConciergeSessionStatus {
  COLLECTING
  PROCESSING
  COMPLETE
  FAILED
}

enum ConciergeRole {
  USER
  ASSISTANT
  SYSTEM
}

model ConciergeSession {
  id              String                 @id @default(cuid())
  publicToken     String                 @unique
  shopId          String
  shop            Shop                   @relation(fields: [shopId], references: [id], onDelete: Cascade)
  experienceId    String?
  experience      Experience?            @relation(fields: [experienceId], references: [id], onDelete: Cascade)
  status          ConciergeSessionStatus @default(COLLECTING)
  resultCount     Int                    @default(8)
  answersJson     String                 @default("[]") // JSON array of user answers/messages
  queryRaw        String?                // Original query text (first user message or extracted from answers)
  queryNormalized String?                // Normalized query (lowercased, trimmed) for grouping
  clientRequestId String?
  sessionToken    String?                // Stable token for attribution (set at creation, typically same as publicToken)
  chargedAt       DateTime?
  createdAt       DateTime               @default(now())
  updatedAt       DateTime               @updatedAt
  messages        ConciergeMessage[]
  result          ConciergeResult?

  @@unique([shopId, clientRequestId])
  @@index([shopId])
  @@index([publicToken])
  @@index([sessionToken])
  @@index([shopId, clientRequestId])
}

model ConciergeMessage {
  id        String           @id @default(cuid())
  sessionId String
  session   ConciergeSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  role      ConciergeRole    @default(USER)
  text      String?
  imageUrl  String?
  createdAt DateTime         @default(now())

  @@index([sessionId])
}

model ConciergeResult {
  id             String           @id @default(cuid())
  sessionId      String           @unique
  session        ConciergeSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  productHandles Json
  productIds     Json?
  reasoning      String?
  createdAt      DateTime         @default(now())
}

model Subscription {
  id                    String    @id @default(cuid())
  shopId                String    @unique
  shop                  Shop      @relation(fields: [shopId], references: [id], onDelete: Cascade)
  planTier              PlanTier  @default(TRIAL)
  shopifySubscriptionId String? // Shopify billing subscription ID
  shopifyChargeId       String? // Shopify billing charge ID
  status                String    @default("active") // active, cancelled, expired
  currentPeriodStart    DateTime?
  currentPeriodEnd      DateTime?

  // Credits (using x2 multiplier to avoid float drift: 0.5 credit = 1 unit)
  creditsIncludedX2 Int @default(0)
  creditsAddonX2    Int @default(0)
  creditsUsedX2     Int @default(0)

  // Experience limits
  experiencesIncluded Int @default(0)
  experiencesAddon    Int @default(0)

  // Add-ons
  advancedReportingAddon Boolean @default(false)
  
  // Recurring add-on enable dates (for monthly billing from enable date, not cycle rollover)
  experiencesAddonEnabledAt    DateTime? // When experiences add-on was first enabled
  advancedReportingEnabledAt   DateTime? // When advanced reporting was first enabled

  // Shopify subscription IDs for usage billing
  shopifySubscriptionGid      String? // AppSubscription gid
  shopifyRecurringLineItemGid String? // recurring line item gid
  shopifyUsageLineItemGid     String? // usage line item gid (needed for appUsageRecordCreate)

  // Billing cycle anchor
  billingIntervalAnchor DateTime? // when we anchor cycle if Shopify dates missing

  // Cancellation grace period (for preserving unused add-on credits and recurring add-ons)
  cancelledAt                          DateTime? // when subscription was cancelled
  preservedCreditsAddonX2             Int      @default(0) // unused add-on credits preserved at cancellation
  preservedExperiencesAddon           Int      @default(0) // recurring experience pack preserved at cancellation (0, 3, or 10)
  preservedAdvancedReporting          Boolean @default(false) // recurring advanced reporting preserved at cancellation
  preservedExperiencesAddonEnabledAt   DateTime? // enable date preserved at cancellation (for monthly billing restoration)
  preservedAdvancedReportingEnabledAt DateTime? // enable date preserved at cancellation (for monthly billing restoration)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum UsageEventType {
  SESSION_STARTED
  AI_RANKING_EXECUTED
  RESULTS_VIEWED
  RECOMMENDATION_CLICKED
  ADD_TO_CART_CLICKED
  CHECKOUT_STARTED
  EXPERIMENT_EXPOSED
}

model UsageEvent {
  id            String         @id @default(cuid())
  shopId        String
  shop          Shop           @relation(fields: [shopId], references: [id], onDelete: Cascade)
  eventType     UsageEventType
  metadata      String? // JSON metadata (e.g., sessionId, experienceId)
  creditsBurned Float          @default(0)
  createdAt     DateTime       @default(now())

  @@index([shopId, createdAt])
  @@index([shopId, eventType, createdAt])
}

model AIRankingCache {
  id            String   @id @default(cuid())
  cacheKey      String   @unique // Hash of userIntent + product catalog
  shopId        String
  shop          Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)
  userIntent    String   // Normalized user intent for debugging
  productHash   String // Hash of product handles (for cache key generation)
  rankedHandles String // Cached ranked handles array (JSON string for SQLite)
  reasoning     String? // Cached reasoning
  resultCount   Int // Number of results cached
  createdAt     DateTime @default(now())
  expiresAt     DateTime // Cache expiration (24-48 hours)

  @@index([shopId, expiresAt])
  @@index([cacheKey, expiresAt])
  @@index([expiresAt]) // For cleanup of expired entries
}

model OrderAttribution {
  id              String   @id @default(cuid())
  shopId          String
  shop            Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)
  orderId         String   // Shopify order ID
  orderNumber     String?  // Order number/name for display
  sessionId       String?  // ConciergeSession ID (if directly attributed)
  sessionToken    String?  // ConciergeSession publicToken (for lookup)
  attributionType String   // "direct" | "assisted" | "unattributed"
  totalPrice      String   // Order total price as string (to avoid float precision issues)
  currencyCode    String?
  createdAt       DateTime @default(now())

  @@unique([shopId, orderId])
  @@index([shopId, createdAt])
  @@index([orderId])
  @@index([sessionId])
  @@index([sessionToken])
}

model AttributionAttempt {
  id            String   @id @default(cuid())
  shopId        String
  shop          Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)
  sessionId     String   // ConciergeSession ID
  sessionToken  String?  // ConciergeSession publicToken (for lookup)
  cartToken     String?  // Shopify cart token (no PII)
  checkoutToken String?  // Shopify checkout token (no PII)
  matchedAt     DateTime? // When this attempt was matched to an order
  createdAt     DateTime @default(now())

  @@index([shopId, sessionId])
  @@index([shopId, cartToken])
  @@index([shopId, checkoutToken])
  @@index([sessionId])
  @@index([createdAt])
}

model Experiment {
  id        String   @id @default(cuid())
  shopId    String
  shop      Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)
  key       String   // Experiment identifier (e.g., "button_label_v2")
  isActive  Boolean  @default(false)
  variants  Json     // JSON array of variant configurations: [{ name: "control", config: {} }, { name: "variant_a", config: {} }]
  startedAt DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([shopId, key])
  @@index([shopId, isActive])
}

model AppError {
  id          String   @id @default(cuid())
  shopId      String?
  shop        Shop?    @relation(fields: [shopId], references: [id], onDelete: Cascade)
  requestId   String
  route       String?
  message     String
  stack       String?
  contextJson String?  // JSON metadata
  createdAt   DateTime @default(now())
}

model AppProxyLog {
  id          String   @id @default(cuid())
  shopId      String?
  shop        Shop?    @relation(fields: [shopId], references: [id], onDelete: Cascade)
  requestId   String
  route       String
  status      Int
  durationMs  Int
  createdAt   DateTime @default(now())
}
